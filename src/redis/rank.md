---
title: Redis面试题频排序
pageInfo: false
editLink: false
comment: false
sidebar: false
---

------

------

### 介绍一下Redis的缓存击穿、穿透和雪崩？以及对应怎么解决？(6次)

> [!NOTE]
>
> | **问题类型** | **定义**                                                     | **原因**                                                     | **解决方案**                                                 |
> | ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | **缓存击穿** | 指的是**某个热点数据的缓存过期**后，大量请求直接打到数据库，导致数据库压力激增。 | - 缓存中某个热点键过期。- 大量用户同时请求该数据，缓存失效后瞬间访问数据库。 | 1. **热点数据永不过期**：   - 为热点数据设置较长的过期时间，或直接设置永不过期。2. **提前预热**：   - 在缓存数据即将过期前主动刷新缓存。 |
> | **缓存穿透** | 指的是**请求的数据在数据库中不存在**，由于缓存中也没有该数据，每次请求都会直接打到数据库，可能引发数据库压力激增。 | - **恶意攻击**：传入大量不存在的 key。- **查询条件错误**：请求的数据本就不存在。 | 1. **缓存空值**：   - 对数据库查询结果为空的数据也缓存（如存入特殊标识 `null` 或默认值），并**设置较短过期时间**。2. **参数校验**：   - 请求进入系统时先校验参数是否合法。3. **布隆过滤器**：   - 使用布隆过滤器提前拦截不存在的请求。 |
> | **缓存雪崩** | 指的是**大量缓存同时过期**或 Redis 宕机，大量请求打到数据库，导致数据库压力过大，甚至崩溃。 | - 缓存中大量 key 设置了相同过期时间，集中失效。- Redis 宕机或不可用。 | 1. **过期时间随机化**：   - 设置缓存过期时间时，增加随机值，避免大量 key 同时过期。2. **多级缓存**：   - 增加本地缓存（如 Guava Cache）作为一级缓存，缓解 Redis 宕机压力。3. **Redis 高可用**：   - 使用 Redis Cluster 或主从复制，增强容灾能力。**4.后台缓慢更新缓存**，缓存永不过期 |

### 如何用Redis实现分布式锁？ (6次)

> [!NOTE]
>
> 1. 设置键作为锁
>
>    - `SET key value NX PX ttl`。加锁操作是原子性的（redis保证）
>    - 一个key表示唯一的锁
>    - value唯一标识获得锁的客户端
>    - 设置ttl，保证锁不会因为客户端异常不能正常释放
> 2. 释放锁
>
>    - 原子性：先检查锁的值是否匹配，匹配再删除（lua脚本保证）
> 3. 可靠性宕机：
>    - Redlock投票机制
>

### 如何保证数据库和缓存的一致性？(4次)

> [!NOTE]
>
> > ### cacheaside缓存旁路（读多写少）
> >
> > - 读：先从缓存中读取数据，如果没有就再去数据库里面读数据，然后把数据放回缓存中，如果缓存中可以找到数据就直接返回数据；
> > - 写：**更新数据的时候先把数据持久化到数据库，然后再让缓存失效**。
> > - 尤其适用于缓存来源于慢查询
> >
> > > - 先写后读：（读完成的太快，导致读到的是旧数据的缓存）数据库更新和缓存删除之间，有读操作，可能读到旧缓存数据。虽然再读一次就能得到一致性数据。
> > > - 先读后写：（写完成的太快， 导致读设置了旧数据缓存）可能造成脏缓存（缓存中是写之前的数据），非常极端，因为写+删缓存跑得比读+写缓存还快
> >
> > ### 延迟双删对cacheside进行优化（读多写少）
> >
> > cacheaside + 删除缓存后一段时间再次删除缓存
> >
> > - 减少了cacheaside的数据不一致发生的情况
> > - 仍然存在小的时间窗口，在第二次删除缓存之前可能读到旧数据。部分解决了先读后写中的脏缓存（双删对脏缓存进行了清理）。
> >
> > > 延迟双删+间隔读两次可以进一步降低不一致性
> >
> > ### read/write through：（读多写少）将读取/查询数据库的操作由缓存代理，而不是调用者
> >
> > - read：读时缓存未命中，Read Through用缓存服务自己来加载数据库中数据 。而并不是由调用者来完成。
> > - write：
> >   - 如果没有命中缓存，（可以写缓存）直接更新数据库，然后返回。
> >   - 如果命中了缓存，则更新缓存，然后再由缓存自己更新数据库（这是一个同步操作）
> >
> > > 依旧会有不一致的情况：先读后写：读未命中且跑得慢、写未命中且跑得快
> >
> > ### writeback（读少写多）
> >
> > 数据进行持久化存储时候，异步批量写回
> >
> > > 依旧不是强一致的，而且数据可能会丢
> >
> > ### 分布式事务（强一致性）
> >
> > 将数据库更新和缓存更新放在同一个事务当中，能够保证强一致性



### Redis有哪些数据结构？(4次)

> [!NOTE]
>
> - 字符串
> - 列表
> - 哈希表
> - 集合
> - 有序集合

### 介绍一下Redis的持久化方式？(4次)



### 介绍一下布隆过滤器？(4次)

> [!NOTE]
>
> 1. 概述
>
>    布隆过滤器是一种**空间效率很高的概率型数据结构**，用于判断一个元素是否**可能存在**于集合中。它可以快速判断某个元素是否在集合中。**不会把存在的判断成不存在**。
>
> 2. 原理
>
>    - 初始化位数组m并设计k个哈希函数
>
>    - 添加元素
>
>      k个哈希函数k个哈希值，置1
>
>    - 查询元素：
>
>      - 如果都是1，可能存在
>      - 如果都是0，一定不存在
>
> 3. 优点
>    - 内存小
>    - 速度快
>    - 通过调整 `k` 和 `m` 的取值，可以在内存占用和误判率之间找到平衡
> 4. 缺点：
>    - 会把不存在的判为存在
>    - 不能直接删除元素
>
> 5. 应用：
>    - 解决缓存穿透问题：布隆返回false则一定不存在redis当中。避免打到数据库。

### 介绍一下Redis的Zset的底层数据结构？ (3次)

### Redis为什么采用跳表作为Zset底层数据结构？(2次)

### 介绍一下Redis数据结构的应用场景？(2次)


### 使用旁路缓存(Cathe Aside)策略会有什么问题？(2次)

### Zset怎么实现插入和删除？如何确定Zset新节点的层数？(2次)

### Redis哈希扩容的过程？(2次)

### 介绍一下AOF和RDB的优点和缺点？(1次)

### **Redis支持回滚吗？**(1次)

### 介绍一下Redis的底层数据结构？(1次)

### 如何提高Redis的性能？(1次)

### 怎么解决缓存脏数据？ (1次)

### Redis实现分布式锁节点上锁之后解锁之前挂掉了怎么办？  (1次)

### Redis哪里用到了单线程，哪里用到了多线程？ (1次)

### 使用Redis的优点有哪些？ (1次)

### 为什么选择Redis作为MySQL的缓存？ (1次)

### Redis宕机要怎么进行数据恢复？ (1次)


### 哨兵集群有什么缺点？ (1次)

### 热key失效怎么解决？(1次)


### AOF文件过大会怎么样？(1次)

### Redis持久化时可以进行写操作吗？(1次)

### 删除缓存失败怎么办？(1次)

### 介绍一下Redis的集群模式？(1次)

### 集群的脑裂是什么？如何解决脑裂？(1次)

### Redis是如何实现I/O多路复用的？(1次)

### select、poll、epoll在Redis中如何应用的？使用时会不会陷入内核态？(1次)

### Redis原子性操作的原理？(1次)

### 介绍一下Redis的主从集群？(1次)

