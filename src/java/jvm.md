---
title: Java
author: xmy
---

9.20



### 内存区域

- 一个main函数就是一个jvm进程

  - jvm线程（多个）main函数对应的是主线程

    - 虚拟机栈：

      Java函数调用，比如局部变量、参数

    - 本地方法栈

      其他语言写的函数调用

    - PC程序计数器

  - 堆内存（JVM管理）

    所有对象实例和数组，垃圾回收主要区域

    - **字符串常量池**

    - 新生代
    - 老年代
    - 永久代（方法区在这里实现，新版本已经移除永久代，方法区实现移动到本地内存的元空间）

- 本地内存(操作系统分配和管理)

  - 元空间（之前叫方法区、在线程共享部分）

    - 类的元数据（字段、结构、方法等）

    - **运行时常量池**
  - 直接内存
  
  <img src="C:\Users\HanFaye\AppData\Roaming\Typora\typora-user-images\image-20250919142030356.png" alt="image-20250919142030356" style="zoom:30%;" />

> **堆内存** 
>
> - 适合管理 Java 对象和动态分配的内存，
> - 由 JVM 垃圾回收器管理，避免内存泄漏。
>
> **本地内存** 
>
> - 提供更高性能的直接内存访问和与操作系统的交互能力，
> - 同时支持 JVM 运行时元数据的存储和管理。
> - 通过直接内存避免数据拷贝（如果数据拷贝在JVM堆内存：JVM堆内存>本地内存>IO）

> [!NOTE]
>
>  **内存区域**、**OOM 错误原因** 和 **排查方法** 
>
> | **内存区域**         | **OOM 错误类型**                                     | **可能原因**                                                 | **排查方法**                                                 |
> | -------------------- | ---------------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
> | **堆内存（Heap）**   | `java.lang.OutOfMemoryError: Java heap space`        | 1. 创建了**大量对象**，超过堆内存限制。2. 内存泄漏：**对象未被回收**（如集合持有大量对象）。3. **堆内存配置过小**。 | 1. 检查和调整堆内存大小：`-Xms`、`-Xmx` 参数。2. 启用堆转储：`-XX:+HeapDumpOnOutOfMemoryError`，用工具（如 Eclipse MAT 或 JVisualVM）分析堆转储文件。3. 启用 GC 日志：`-XX:+PrintGCDetails`，观察垃圾回收频率和内存占用。 |
> | **方法区（元空间）** | `java.lang.OutOfMemoryError: Metaspace`              | 1. **动态生成类过多**（如大量使用反射、动态代理）。2. 元空间大小设置过小。 | 1. 检查元空间大小：`-XX:MetaspaceSize` 和 `-XX:MaxMetaspaceSize` 参数，适当增大元空间。2. 使用 JVisualVM 等工具分析类加载情况，排查类是否频繁加载或未被卸载。 |
> | **虚拟机栈**         | `java.lang.StackOverflowError` 或 `OutOfMemoryError` | 1. 方法**递归过深，导致栈帧溢出**。2. **创建了过多线程，耗尽栈内存**。 | 1. 检查栈大小：使用 `-Xss` 参数调整每个线程的栈大小。2. 使用 JStack 查看线程堆栈，分析是否存在无限递归或线程过多问题。（优化代码，使用循环而不是递归） |
> | **直接内存**         | `java.lang.OutOfMemoryError: Direct buffer memory`   | 1. 使用 `ByteBuffer.allocateDirect()` **分配的直接内存过多**，超过限制。2. 直接内存**未及时释放**。 | 1. 检查直接内存大小：`-XX:MaxDirectMemorySize`，适当增大直接内存限制。2. 检查代码中是否存在未释放的直接内存（如 Netty 中的 ByteBuffer）。 |
> | **本地方法栈**       | `java.lang.OutOfMemoryError`                         | 1. JNI 调用的**本地方法分配内存失败**。                      | 1. 检查是否存在 JNI 调用内存泄漏。2. 使用工具（如 JProfiler）检查本地方法的内存使用情况。 |
> | **代码缓存区**       | `java.lang.OutOfMemoryError: CodeCache`              | 1. JIT 编译器生成的动态代码过多，超出代码缓存区限制。        | 1. 检查代码缓存区大小：`-XX:ReservedCodeCacheSize` 参数，适当增大缓存区。2. 检查是否存在过于复杂的动态代码生成。 |
>
> 





![image-20210909114511412](C:\Users\HanFaye\OneDrive\桌面\CSView\src\63f8b8bdf144a010079d4c87.jpg)

HotSpot在JDK1.8之前方法区就是永久代，永久代就是方法区。

JDK1.8后删除了永久代，改为元空间，元空间在直接内存中。方法区就是元空间，元空间就是方法区。

创建一个线程，JVM就会为其分配一个私有内存空间，其中包括**PC、虚拟机栈和本地方法栈**

**PC**

用来指示**下一个执行的字节码指令**，基于这一点就能实现代码的控制流程

为了确保每个线程切换回来都能从上次的位置继续运行，PC必须是线程私有的，切换出去时需保存各自的PC

**虚拟机栈**

虚拟机栈中**一个栈帧压入就对应一个方法的调用，栈帧弹出就对应方法返回**。栈帧中包含：局部变量表、操作数栈、动态链接、方法出口信息。

局部变量表也就是常说的栈内存，用来存储基本类型和引用

HotSpot不支持动态扩展虚拟机栈，在创建线程时就确定了虚拟机栈的最大深度，如果申请不了这么多内存，就会抛出OOM错误，如果线程在运行时调用了很多方法，到达了栈的最大深度，就会抛出SOF错误

**本地方法栈**

和虚拟机栈相同，区别仅在于虚拟机栈中是java方法，本地方法栈中是native方法，但HotSpot中已经将二者合而为一了。

**堆**

JVM中最大的一块内存空间，所有对象实例和数组都在这里分配内存，所有线程共享堆内存。

JDK1.7开始默认开启了逃逸分析，如果一个对象只在一个线程中被引用了，则该对象可以直接在栈上分配内存空间。

堆也叫GC堆，是垃圾回收的主要区域。为了便于垃圾回收，JDK1.8之前将堆分为三个部分：

1. 新生代
2. 老年代
3. 永久代

而1.8之后将永久代删除了，取而代之的是元空间，元空间则在直接内存中。

此外，新生代还细分为eden、from survivor（s0）和to survivor（s1）

当新对象实例产生时，年龄为0，首先被分配在eden里，在一次gc后，如果还存活，就被扔到survivor里，并且年龄+1，当年龄增加到一定程度后就被扔到老年代里。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold  来设置。

**方法区**

存放被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

1.8之前是永久代，属于堆内存。1.8之后是元空间，属于直接内存。

永久代受JVM创建时分配的最大堆内存限制，而元空间则受系统内存限制，可以存储更多。

**常量池**

分为字符串常量池和运行时常量池

1.8之后字符串常量池在堆中，而运行时常量池在元空间

**直接内存**

在JVM进程的内存空间之外，属于系统内存。

JVM可通过native方法对其进行直接操作，而无需在使用时将其拷贝到JVM内存区。

### 对象创建过程
![Java创建对象的过程](https://pic.imgdb.cn/item/63f8b9aef144a010079ea749.jpg)

1. **类加载检查：**

   JVM遇到一条new指令时，先检查能不能在常量池中定位到该类的符号引用，并检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有就要先进行类加载。类已被加载就通过检查。

2. **分配内存：**

   类加载检查通过后JVM为新对象分配内存，对象所需的内存大小在类加载完成后就确定了，JVM会在堆中按照**指针碰撞**或**空闲列表**的方式为对象划分出一块空间，选择哪种方式会根据垃圾收集器的算法而定。此外，内存分配还要保证线程安全，JVM采用**CAS+失败重试**或**TLAB**的方式保证线程安全。

   CAS+失败重试：乐观锁的一种实现，每次占用资源不加锁，而是不断尝试占用。

   TLAB：线程创建时预先在堆中给线程分配一块内存，称为TLAB，专门用来存放该线程运行过程中创建的对象，而TLAB满了时，采用上述CAS在堆的其它内存中分配

3. **初始化零值：**

   将对象的字段设为默认零值，不包括对象头

4. **设置对象头：**

   在对象头中设置这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄、是否启用偏向锁等信息

5. **执行init方法：**

   初始化对象，即按照程序员写的构造方法给对象进行初始化。

> [!NOTE]
>
> #### 堆空间基本结构
>
> - 新生代
>   - eden
>   - survivor
>     - s0
>     - s1
> - 老生代
>
> #### 分配原则
>
> - 大多数情况，对象在eden中进行分配。第一次垃圾回收还存在，则被分配到s区域内。
> - 大对象（大量连续内存）：字符串、数组等直接进入老年代
>
> - 新生代进入老年代：每一次新生代的gc年龄都+1
>   - 初始默认时，年龄达到15，进入老年代
>   - 动态阈值：选取min(原始阈值，占用s区域内存一半的年龄)
>
> #### 收集区域
>
> - 部分收集partial gc
>
>   - 新生代收集young gc
>
>     空间分配担保：
>
>     - 动态计算晋升对象所需要的内存大小
>     - 老年代够用，直接younggc
>     - 老年代不够用，fullgc。如果失败，则会报错oom
>
>   - 老年代收集old gc
>
>   - 混合收集：整个新生代和部分老年代
>
> - 整堆收集full gc
>
>   - 堆+元空间（元空间是实现了方法区）
>
> #### 判定对象死亡算法
>
> - **引用计数算法**
>   - 很少用，因为循环引用
> - **可达性分析**
>   - 一系列gc roots出发，查看可达的对象。gc roots有哪些？
>     - 虚拟机栈
>     - 本地方法栈
>     - 方法区：类静态属性引用的对象
>     - 方法区：常量引用的对象等等
>
> #### gc算法
>
> - **标记-清除**算法：
>   - 两过程效率不高
>   - 内存碎片
> - **标记-复制**算法（适合新生代）
>   - 实际上可用空间变为原来的一半，复制的过程也可以整理内存碎片
>   - 不适合老年代：老年代存活数量大，复制性能差
> - **标记-整理**算法（适合老年代）
>   - 针对老年代
>   - 让存活对象向一端移动，适合老年代这种垃圾回收频率不是很高的场景
>
> - **分代收集**算法
>   - 根据各个区域的特点，选择合适的gc算法
>
> #### 为什么要分代？
>
> - 对象生命周期的特点：提高gc效率
>   - 短生命周期（大多数）
>   - 长生命周期
> - 可以提高单次gc的时间
>   - 新生代快
>   - 老年代慢
> - 减少内存碎片
>   - 新生代使用复制算法
>   - 老年代使用标记整理算法
>
> #### 垃圾回收器g1
>
> 每次根据允许的收集时间，优先选择回收价值最大的 Region

### GC

**内存分配与回收**

新对象优先被分配在eden里，年龄设置为0，经历第一次gc后如果还存活，就被扔到survivor中，并且年龄+1，随后每经历一次gc如果还存活就年龄+1，如果年龄超过了上限（默认15），就被扔到老年代中。通过-XX：MaxTenuringThreshold设置上限。

此外，JVM还有动态年龄判定机制：如果在survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到年龄超过上线。

如果是过大的对象，为了避免其来回复制，可以在创建时直接扔到老年代里。通过-XX：PretenureSizeThreshold设置，只支持Serial和ParNew。

![image-20210911183213177](https://i.loli.net/2021/09/12/MdbG2zIoR4FpKNr.png)

hotspot中gc分为两类：部分收集partial gc和全收集full gc。

部分收集又分minor gc、major gc和mixed gc

minor gc：只对新生代进行回收

major gc：只对老年代进行回收（有时也指代full gc）

mixed gc：对整个新生代和部分老年代进行回收

全收集full gc：对整个堆和方法区（hotspot中的元空间）进行回收

**判别对象、常量、类死亡的方法**

- **对象**

1. **引用计数法：**

   对象中设置一个引用计数器，每当该对象被引用时，引用计数器就会+1，失去一个引用时就会-1。引用计数器为0时就代表已经死亡，不会再被引用了。这种判别方式有个缺点，如果两个对象互相引用，但又没有外界对它们的引用，则它们引用计数都为1，会一直存在，但没有意义。

2. **可达性分析法：**

   设置一组对象为**gc roots**，如果一个对象没有能到达任何一个gc root的引用链，则判别这个对象死亡。一般一个线程启动后并列创建的一组对象会构成gc roots，gc roots内部引用的对象就是非gc root。![image-20210911220120397](https://i.loli.net/2021/09/12/Mncmzl8OVLdvBHE.png)

- **常量**

没有被任何对象引用时就是废弃的

- **类**

同时满足如下三点就是无用的类

1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader  已经被回收。
3. 该类对应的 java.lang.Class  对象没有在任何地方被引用，无法在任何地方通过反射访问该类
   的方法。

**引用类型都有哪些？**
1. **强引用**

   ```java
   Object strong = new Object();
   ```

   一个对象如果被引用，且最高级别是强引用，就**不会被回收**。

2. **软引用**

   ```java
   SoftReference<Object> soft = new SoftReference<>(new Object());
   ```

   一个对象如果被引用，且最高级别是软引用，发生gc时**内存足够就不会被回收，内存不够就会被回收。**

3. **弱引用**

   ```java
   WeakReference<Object> weak = new WeakReference<>(new Object());
   ```

   一个对象如果被引用，且最高级别是弱引用，发生gc时不管**内存够不够都会被回收。**

4. **虚引用**

   ```java
   ReferenceQueue<Object> queue = new ReferenceQueue<>();
   PhantomReference<Object> phantom = new PhantomReference<Object>(new Object(), queue);
   ```

   虚引用创建时必须搭配ReferenceQueue。

   一个对象如果被引用，且最高级别是虚引用，就等于没有被引用，发生gc时不管内存够不够都会被回收。

   虚引用看起来和弱引用没啥区别，只是必须搭配ReferenceQueue。

   用虚引用的目的一般是跟踪对象被回收的活动。

5. **ReferenceQueue**

   软引用、弱引用和虚引用在创建时都可以关联一个ReferenceQueue，其中虚引用必须关联，其余两个可选关联。

   关联了ReferenceQueue的引用所引用的对象在被回收内存之前，这个引用会被JVM加入到关联的ReferenceQueue中。通过这样的机制，我们就能通过监听该队列，在对象内存被回收前进行一些自定义处理。

在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生。

**GC算法有哪些？**
- **标记-清除**
：先标记上所有存活的对象，再一次性回收掉没被标记的，这是最基础的算法，后面的几个都是对其效率和空间碎片问题做了优化。
碎片问题会导致都是小空隙，装不下大对象，而如果将对象整理起来就会空出更大的空隙。

- **复制**
：将内存分为两块，只用其中一块，当用的这一块满了后，还是对其中存活的对象进行标记，然后将这些被标记的逐个复制到另一块内存，最后将剩余的死亡对象一次性回收，说白了就是两块内存来回倒。由于一次gc需要处理的总内存变小了，效率也就提升了。

- **标记-整理**
：和标记-清除一样，先标记存活对象，然后将它们堆到一端，最后回收掉末端以外的对象。

- **分代收集**
：新生代死亡对象比较多，一般用复制算法。老年代死亡对象比较少，一般用标记-清除或标记-整理算法

### 类加载流程

**加载**

将字节流读入JVM内存，在方法区存储为一个数据结构，同时创建一个对应的Class对象供程序访问。

**验证**

一共4步：

1. 文件格式验证

   验证读进来的字节流是否符合Class标准格式。

2. 元数据验证

   格式对了之后，验证一下里边的数据合不合理。

   比如：这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）。

3. 字节码验证

   分析类的方法体（Class文件中的Code属性），确保方法在运行时不会危害虚拟机。

4. 符号引用验证（发生在解析阶段）

   检查常量池中引用的外部类是否存在，是否可以正常访问。

**准备**

类变量（静态变量）分配内存并设置初值

其中如果是final修饰的，意味着在Class文件中，该字段的属性表中存在ConstantValue属性，此时初值设置为代码里写的。

如果不是，就设置为零值，等到初始化阶段再赋值。

**解析**

把符号引用（地址无关）转化为直接引用（地址相关）

**初始化**

执行clinit方法，这里要注意不是构造方法，而是执行静态语句，包括静态变量赋值和静态块

